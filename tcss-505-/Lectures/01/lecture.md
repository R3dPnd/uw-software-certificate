Robert Cordingly
Robert Cordingly
Is, if we take a look at this chart, you can see that.
Good morning, everyone. We'll give it a couple of minutes for people to show up.
as I admit people from the waiting room.
So we'll get started at 9, 35, as we usually do.
Tcs 505. 0, yeah, woo!
We'll get started in a couple of minutes for the people who just joined.
Well.
let's we'll see if we can get a few more people to join, and then they're coming and we almost are pretty close to.
Haven't everyone here
still a couple more? We'll we'll get started at 9, 35.
Okay, welcome everyone to Tcss. 505. The final quarter of the Gcste program. So,
yeah, welcome back. It's been a good hopefully. It's been a good 3 months, roughly, maybe a bit more, since the last time you had me for a class. I'm back.
So
You'll probably notice that the courses in this last quarter of the program are a fair bit different than the previous 2, where, instead of being like
having one strictly programming based class and one theory based class. They're both more practical than than the previous ones. This one's still like the theory-based class, we'll be talking about how computers work like the physical hardware and the the abstract ideas we use to make programming easier. That's what this class will be about. And we'll get into a bit of that today. But.
as always, this 1st
class of the quarter is really just kind of an overview of what the course is about what we'll
what what's going on in the canvas. It all should be fairly familiar. Since you had my class in 501. It's all formatted pretty much the same. But we'll once again go through the review of that just in case. So
I know. I definitely remember everyone here who's in the course. But just as a little bit of a refresher, I'd like to just go through everyone once again in the course with a few different questions this time. So just give a little introduction of yourself
just as a refresher. It has been a few months, and then maybe say what your favorite thing that you've learned in Gcsde so far is how much of a better programmer you are. That's something. Also, I hope, is that everyone is at least a twice as good programmer as they were when I last had you in 501.
So hopefully, you've learned a lot what your favorite thing is, and then a random question of, Have you ever used a virtual machine before? Because that's going to be kind of the focus of the 1st lecture? And it's like the 1st thing that you need to do in this course to get going. So and then last little bit congratulations. You're you're
you're in the final stretch here the last few months of the program in this last quarter.
So I don't know if we would just want to do like volunteers, or I'll just go through the list.
I know.
James  Godwin
James  Godwin
00:25:19
Barbara.
Robert Cordingly
Robert Cordingly
00:25:21
Sure we'll just volunteers person that will go through the list.
James  Godwin
James  Godwin
00:25:24
Cool. Hello! I'm James still, James. I've always been James. What have I learned? That's my favorite thing so far, like, I think, last quarter dynamic programming like being exposed to that. And I go. Hey, this is actually really useful. And, like, you know, wonderful it, it clicked with me so like. I appreciate learning about that. And yes, I have used vms before, not in a hot minute. But I have some familiarity with them.
Robert Cordingly
Robert Cordingly
00:25:50
Great any other second volunteer sean looks like.
Sean Warlick
Sean Warlick
00:25:56
Yeah. Good morning. Still, Sean.
yeah, I think the I think the thing I've really enjoyed most has sort of been graph theory.
But
everything's a graph, or you can turn everything into a graph if you want. Even I was thinking about the other day, even like
as I was trying to resolve some merge conflicts at work you, you get history as a graph.
So that's kind of cool. And you know, it's definitely
hopefully write. You know, better. Code. So yeah.
Robert Cordingly
Robert Cordingly
00:26:28
Great
cool. Okay, if there's no longer any volunteers, we'll start going in alphabetical order. So my 1st name, Ainsley.
Ainsley Yoshizumi
Ainsley Yoshizumi
00:26:46
Yeah, I oh, I was gonna go anyways.
Yeah. Still, Ainsley. My favorite thing. I I think I have to agree with Sean, too like, was like graph theory. And then also learning about like map coloring was pretty cool. And then no, I've never used a virtual machine before.
Robert Cordingly
Robert Cordingly
00:27:05
Great.
Well, you'll learn today. Well, you'll use it for the 1st time today, hopefully.
Ainsley Yoshizumi
Ainsley Yoshizumi
00:27:10
Awesome.
Robert Cordingly
Robert Cordingly
00:27:12
So next up is Deepika.
If you're here.
Deepika Chinnathambi
Deepika Chinnathambi
00:27:21
Yeah. Hi, you can call me deepika. And my favorite thing is object oriented concepts. Everything, everything in the Gcsd program. It's very new to me.
so I have never used a virtual machine mission before.
Thank you.
Robert Cordingly
Robert Cordingly
00:27:41
Great.
Next up is Derije Derije.
Dereje Teshager
Dereje Teshager
00:27:46
Yeah, better day.
Yeah. My name is Dharaj. And
my favorite thing about this Sd is
working with teams on 5 or 4 we used
we work on the project called fire system Watcher.
Robert Cordingly
Robert Cordingly
00:28:05
Hmm.
Dereje Teshager
Dereje Teshager
00:28:06
And yeah, we enjoyed the working with the with my team members.
and I never use virtual machines before.
Robert Cordingly
Robert Cordingly
00:28:19
Nice. Yeah, I I'm definitely interested in hearing what you all have done in a
5 0, 3 and 5. 0, 4, because I'm not overly familiar with actually, those classes. I don't know what they all do. So that's cool.
Yeah. Next up James already went. So Janine.
Jannine deBiddick MacGormain
Jannine deBiddick MacGormain
00:28:43
Good morning, everyone. I'm still Janine. I am interested in algorithms, data structures, database, various design patterns. And beyond, as always. And I haven't used a virtual machine before, that's all. Thank you.
Robert Cordingly
Robert Cordingly
00:29:07
Great Liam's up next.
WEILAN LIANG
WEILAN LIANG
00:29:11
Yeah. It's me, right
Robert Cordingly
Robert Cordingly
00:29:15
No, no.
we're going by 1st name. Liam.
Yeah.
Liam Wilkenson
Liam Wilkenson
00:29:23
Hey? Yeah. Yep. Still, Liam. I think as broad as it is. The favorite thing has just been the different design patterns.
just kind of been like.
I don't know this last quarter. There's like a basically a booklet of all the different ones that was provided from Tom, and I think it's that was super useful to, even if we didn't touch on them. It's like you kind of go through and figure out like
the the pattern that may best work for some problem that's like basically already been solved for you. You just need to implement it.
So it's been really really useful. And I I don't think I've ever used a virtual machine before, so this will be a very interesting quarter. I think.
Robert Cordingly
Robert Cordingly
00:30:01
Great.
Yeah, you'll come to learn in computer science that most problems are already probably solved.
Well, there's still some that aren't. But the vast majority.
Okay, next up is, Maddie. Looks like.
Maddy
Maddy
00:30:20
Hi, I'm still Maddie.
yeah, I have to say, my favorite thing is also learning about all the design patterns, especially implementing them, makes it much easier for me to rationalize
all the problems if I just think of them as little trinkets that do things instead of just lines of code that has been really useful for me.
and I have tried and failed to set up a virtual machine.
because I think I kept downloading like the wrong Iso, or something. So.
Robert Cordingly
Robert Cordingly
00:30:54
Yeah.
Maddy
Maddy
00:30:54
It's very limited.
Robert Cordingly
Robert Cordingly
00:30:56
That's something we will definitely address, because.
depending on the next slide, you'll see people have to do different different things.
So okay, now, Wayland Wayland sorry drunk.
WEILAN LIANG
WEILAN LIANG
00:31:15
We? Yeah, yeah. My name is Weilan. Hi, everyone. So
what would be my favorite thing? I probably yeah, it's same as director, probably teamwork. But it's like a way the object Orientated project, like, we're putting all the things together. And I use the design pattern
to create the actual program is so much fun and put it into work.
I
do kind of use virtual machine before, but never actually use on my computer, on my own computer. So.
Robert Cordingly
Robert Cordingly
00:31:51
Okay, that's alright.
WEILAN LIANG
WEILAN LIANG
00:31:52
Yeah, thank, you.
Robert Cordingly
Robert Cordingly
00:31:55
Okay, great. Thank you for the introductions. Everyone. I see no one has changed since everyone started with. I'm still
1st name.
yeah. So that's good. So if you didn't see one of the very 1st announcements for the course was a hardware survey, basically just asking about your specs of your computer. So we'll go into that and kind of the importance of it. Kind of surprising results. Actually, let me switch back to the
not that one, this one and give it a refresh to see if anyone else has responded since then. Nope.
it is the most up-to-date graph in the slide. So
really interesting results is, we're finally living in a day and age where windows is not the majority which I love to see. I'm the biggest hater of Microsoft, anyway. So half the people are running some flavor of Mac OS, whether it's an intel processor, Mac, or an apple silicon one. We got one person, Linux love to see that, too, and then
couple people on windows. So this is
really the most important question on the hardware survey, particularly because if you're on a windows. Or, Mac, it's going to change which
software you use to run virtual machines. So if you're on windows, Linux or Mac with an Intel processor.
You're going to likely use a program called Virtualbox, where, if you're using an apple silicon processor, Mac. So that's like the m. 1 m. 2, M. 3
laptops. You're going to use a program called Utm, and you're going to have to download a different version of the Linux operating system that we're going to use. And that is because you are using a fundamentally different processor than intel processors or those who which windows use.
You're using what's called an arm processor where windows and older Macs used what were called x 86 processors. And there's actually a chance nowadays that you, if you have
a brand new windows laptop, like the
I forget what Microsoft is calling them, like the copilot plus AI laptops, or whatever you might actually also have an arm processor, and in that case I don't exactly know what you're supposed to do, because I don't know too much about windows on arm. So hopefully, you don't have any of those fancy laptops. But if you do, we'll figure it out. We'll figure out an option.
So alongside that the other responses are pretty typical nowadays. We have cpus with a bunch of CPU cores. So people have 8 or 4, which is also normal. I will actually probably suspect that the 2 people who said, 4 here are likely in the windows category.
because you probably have a thing called hyperthreading, which in theory kind of gives you access to more cores, which we'll talk about later. But we'll talk about what the concept of a CPU core is.
And then, yeah, most people have. Well, everyone has at least 8 GB of RAM with most being over 16, which is good, that doesn't cause any issues. And then the final area that might cause issues. Here
is how much storage space people have. So
people here in the 128 to 256 GB range, you might have to delete some things on your computer to make sure you have enough space. You're going to need at least like 30 GB, free, if not
more, towards like 50 or 60 GB free.
So yeah, that feels bad for
whoever has only a hundred 28 GB. Sorry you might need to delete half the stuff off your computer?
so that
might prove to be an issue. But otherwise, if you have 256 GB or more, you you should be fine.
Yeah. So that's the results of the hardware survey. It kind of just determines a few things about what we're going to do.
what people, how people have to go about installing things. So with that.
for some reason my slide deck got all zoomed in
anyway. So the next thing that we're going to talk about is the syllabus and the canvas page for the course, which should all look pretty familiar. If you're familiar with how 501 went. I'm a big
oh, yeah, every time I zoom that zooms my
sorry things that you you all can't see is getting kind of messed with, anyway. Yeah.
zoom is the same as before. I use the module sections for everything. So every week we'll have a new module with new slides and new feedback survey. And there's a feedback survey assignment, and they work exactly the same as last time where you do. The survey on Google slides, and at the end of the survey. There's a little password that you have to type into an assignment to get credit.
All the same usual things.
with canvas. Here the syllabus might actually be written
slightly differently than it was in 501. But I'm going to apply the same
rules is 501. And honestly, the discord link is probably incorrect, and that Zoom Link's incorrect. I need to update the syllabus in conclusion.
but like last time we're going to have a couple quizzes in the course that are going to be about
20% of your grade. 80% of that will be assignments, and I will work in the feedback surveys in there to be a little bit of
credit also, so make sure to still do those alongside that we will
actually have extra credit on assignments this quarter. So you'll get some bonus points there. And finally, the late policy is still the same where you can turn in things
up to 2 or 3 days late, and you get a 10% late penalty. And that's the other thing is, if you turn an assignment
on time and have
do poorly, you can actually resubmit still, while in the late period, and potentially increase your grade even with the late penalty.
but yeah, that's pretty much all the same. The book. Well, actually, I shouldn't get back into that quite yet, because it's actually in the slides.
So the main course description for this course is that we will be introducing fundamental concepts of modern operating systems and how they function. So
whether you use Mac OS windows or Linux. All of these are going to be apply
in some way.
we're not going to really be talking about how the operating systems are specifically programmed, but in an abstract way, and what tools they provide, how the operating system
is basically the middle man. Between your code that you write and the physical hardware of your system. So how?
The yeah, the lines of code you write actually interact with the hardware.
We'll be talking about various topics, such as processes, threads, memory management, CPU scheduling file systems, virtual machines, software containers. All of those are going to be fundamental topics that we talk about each week
with processes and threads being like what we're starting with today.
But yeah, here is a sort of list of everything that we'll be talking about.
The design of operating systems and what operations they provide you, how you go out and talk to the operating system itself, and it responds back various OS concepts and structures. So we'll learn how the operating system, also, like protects other programs running on the computer
and what it how it runs. Your code. As I mentioned processes and threads.
That bullet is probably like the most important one out of everything.
but once we get into that idea, it will have other things like concurrency, synchronization, monitors and deadlock scheduling memory management, virtual memory. I/O devices, file systems, virtual machines and containers. And we'll also do a little bit of SQL, we'll see if we do that. I'm pretty sure
you all learned a little bit of SQL. In the previous course.
Correct me if I'm wrong.
Did you. Okay, you did good.
So we'll see if we do that.
Not 100% sure might change things a little bit.
Yeah, like I mentioned.
We'll have an assignment roughly every 2 to 3 weeks. There is currently 4 assignments planned.
I'm pretty sure. Maybe 5
And then alongside that we'll have one or 2 quizzes. That'll be 20% of your grade. And the quizzes in this course. Well, I'll spoil it. Spoilers. There's 2 quizzes. One that is basically right in the middle, and one that's at the end of the course, as we did last time.
And then, yeah, some assignments and quizzes will have extra credit points. So do those. If you want some extra credit.
Yeah. So the book for this course is called 3 easy pieces, it's actually entirely available online. So I'm pretty sure the link to that is also
on
the homepage right here, the book website boom 3 easy pieces. It's not like a Pdf or anything. It's literally just a website. So you can see all the different chapters here and then
look at them. Well, it is. Pdf, but the homepage is is this?
So it's all online. You don't need to buy the book. But if for some reason you wanted to, you could buy a physical copy of it somewhere on this website.
Yeah, I don't.
I mean, you can buy a book if you want, but you don't need to.
the one caveat about the book is that it's going to cover many of the topics in the course in C, the C programming language and many of our examples.
Today we'll also utilize the C programming language. It can just do more things that than python can.
But don't worry. All you need to do is like. Look at the code. I'll go through explanations of what's going on, and have a bit of understanding of what's going on. But none of the assignments in this course are actually going to require you to write C code.
So yeah, don't worry about that. C is significantly more challenging to deal with than python is. So
yeah.
but yeah, that's the other thing. If you see a bunch of examples in the book that are in C,
don't worry. We're talking on the abstract level of how things work.
And we don't actually need to write code in C in this course.
So next up is late assignments like I mentioned in the syllabus section, late assignments can be turned up, turned in a few days late each day is a 10% late penalty.
and that can also be a
extra time to do the work. If you do really bad on an assignment, you can turn it in and fix issues after the fact.
yeah, along aside that contact or contact methods for me, you all are familiar with this. There's the class discord we're using the same one as last time. I've already
posted in it a little bit, but discord
messages are a great way to contact me. I respond pretty fast that way, but if you prefer using canvas messages, that's also great. Or just email, my email address is rcoding at Uwedu.
Yeah. So I think that's pretty much everything
to start off with in the canvas any questions about canvas? I guess I have one question for you. All on canvas.
Does it seem to be working
is, are things published? I mean, you all found your way to the zoom call. So that's good.
Sean Warlick
Sean Warlick
00:46:28
Yeah, it's there.
Robert Cordingly
Robert Cordingly
00:46:29
Okay, great. That's always one of the things that I worry about with starting these. The 1st day of these quarters is.
is everything set up properly. So that's good to hear. Yeah.
yeah. Any any questions about canvas.
or any of how the course is formatted that we've talked about
none, for now.
great like, I said, you all have had a class with me before, so it should not be
entirely brand new how things work.
So I think we'll just get right into it. Then, with some course material. Oh.
I guess I have one question.
If you're here.
Who is the one person that's using Linux.
Are you here?
Sean Warlick
Sean Warlick
00:47:36
That's me!
Robert Cordingly
Robert Cordingly
00:47:37
Okay, what distro are you using.
Sean Warlick
Sean Warlick
00:47:39
I have the new law the most recent long term ubuntu.
Robert Cordingly
Robert Cordingly
00:47:43
Dang okay? Good to know, because
you're gonna be using more of a boon queue.
Sean Warlick
Sean Warlick
00:47:52
Yeah, it's well, so.
Robert Cordingly
Robert Cordingly
00:47:54
I've.
Sean Warlick
Sean Warlick
00:47:55
Set up my virtual machine last night for class. And I decided, okay with Fedora.
Robert Cordingly
Robert Cordingly
00:48:01
Okay.
Sean Warlick
Sean Warlick
00:48:01
A fedora machine set up.
Robert Cordingly
Robert Cordingly
00:48:03
Great.
Sean Warlick
Sean Warlick
00:48:04
So it ever since you boom 2 went back to Nome. It's basically no difference.
Robert Cordingly
Robert Cordingly
00:48:10
Yeah.
Sean Warlick
Sean Warlick
00:48:10
So.
Robert Cordingly
Robert Cordingly
00:48:12
Okay, that's good. Still, you still might want to make an ubuntu virtual machine. Part of the things that we're doing also is once we start writing code. That's like highly multi-threaded virtual machines also can be nice to like.
prevent your program from going too crazy. So if you program something or you do a like, make a kernel module. It's better to write that in a virtual machine, so that if you need to kill it, you can just
restart the virtual machine instead of restarting your whole computer. So that's
why I asked Sean, is that you still will want to make probably a ubuntu virtual machine, even though you're using ubuntu.
Sean Warlick
Sean Warlick
00:49:00
Okay.
Robert Cordingly
Robert Cordingly
00:49:02
Okay? And then we got one question from Derije.
No, no, I'm sorry that that was by mistake.
Oh, okay.
Dereje Teshager
Dereje Teshager
00:49:14
Sorry.
Robert Cordingly
Robert Cordingly
00:49:14
No problem.
So
yeah, we'll just get right into it then. So for this course, we will be using the Linux distribution called ubuntu or ubuntu, or however you want to pronounce it, everyone pronounce it differently, but the version we will be using is 22.0 4, which Sean alluded at, which is the latest Lts. Which means long-term stable or long-term support
that
ubuntu released so 24 stands for 2024. So it came out just last year, and the O. 4 is April. So ubuntu does 2 releases per year, one in April and then the other in September.
Is that the 10th month.
Sean Warlick
Sean Warlick
00:50:09
October.
Robert Cordingly
Robert Cordingly
00:50:10
October. Sorry?
yeah. So those October releases are actually every 6 months. So if you want the most brand new feature, you can go with those instead.
So
one thing, if you aren't familiar with the world of Linux is that there's a whole bunch of different distributions, and there can be based on each other. There's actually this whole gigantic tree of Linux distributions. And Ubuntu is probably fairly safe to say is the most popular Linux distribution, and it's based off another version called Debian.
which
in itself has a bunch of other operating systems based off of it and things based off ubuntu. But Debian is kind of one of the core pillars of like
roots of the tree. There's a few other ones like Arc. Arch. Linux is another pillar of the tree.
Fedora is based off a red hat Linux, which is
pretty sure it's another one of the main ones. But yeah, there's a few different options. And actually in the well, there's not just a few options. There's a million options for different Linux distributions. And actually, in the 1st assignment, if you have taken a look at it yet.
You could play with more than one, and you get a little bit of bonus extra credit if you do.
But we're using ubuntu in particular, because it's insanely popular. It's free. It's widely used by many people. If you have any issues, you can Google things. And you'll find 20 million answers, solving all your problems hopefully.
and the long-term stable releases are very popular for servers. So if you use aws, you probably will use ubuntu for some of your backend infrastructure.
And why not?
So? Yeah.
The other last detail that this slide covers is that
we'll get into the concept of package managers and how you install software in Linux. But in particular Ubuntu and many other Debian based
distributions will use the Apt package manager Apt which stands for advanced packaged tool, I'm pretty sure.
But that's how you'll install software on your computer for the most part.
So yeah. So
for those who aren't aware. I will just give a little quick demonstration at this point of what a virtual machine is. So if you haven't noticed when I switch back to this
screen capture over here on my left. This is a Mac. I use a Mac. It's my preferred
computer. We have safari and all the usual Mac things. But what if I want to do
windows things well, what virtual machines ultimately let you do is simulate
or virtualize is the proper term
pretty much an entire, another computer in your computer. So if I wanted to use windows well, I could.
Here's windows 11,
all of fan, all its fancy, new AI things and whatnot that I could play around with. If I want to use paint, I can use paint if I want to use steam and play some games that aren't on Mac.
I can do that. Look at this. I can draw and paint.
And it's basically like, I have a whole nother computer
running a whole different operating system.
That's the main idea of virtual machines. And let's say
I want something other than windows. 11 windows 11 is too new and boring. Well, I could
run any operating system. I could go back in time and run windows Xp. If I wanted to, and play minesweeper, which is for some reason taken out of windows.
I did really great there.
But yeah, you can run virtual machines of basically any operating system. And if you'll if you're a real know the semantics of things. This one technically isn't a virtual machine. But
yeah, you can run all sorts of things. You can run a Linux here. This one is a ubuntu virtual machine. So this is what it'll look like for you guys in your class here. I have some windows open here. But this is generally what ubuntu looks like.
So you can run
basically multiple computers inside your computer, a virtual computer virtual machine. That's what it's called. Yeah. So
that's the super basic introduction of what a virtual machine is. But there's tons of different pros and cons to using these
tools. They're basically just another tool that you have at your disposal. So virtual machines have a variety of pros that I just mentioned. They allow you to run software that may not be supported by your primary OS. This is particularly common if you use a Mac, because we don't have quite the same level of software support as windows does. So. Honestly.
if you've used a Mac in the past, I'm kind of surprised that you might not have used virtual machines because they really expand what you can do
alongside that you can use virtual machines to create more isolated or secure
consistent environments for specific tasks. So, for example, if you were developing software, you could make an ubuntu virtual machine and develop all your software there and all the software you write can just be like, directly sent to a cloud environment that's running ubuntu.
For example, if you needed to install some software that you weren't particularly sure about, maybe it was a little sketchy. Maybe your friend was sending you some random executables that you aren't sure of. Well.
you probably shouldn't run them, but if you had to, you could run them inside of a secure virtual machine that's isolated from your your host operating system. So that in case it was malware, it's not installed on your main computer.
And you can just delete the virtual machine really easily.
And yeah, they just open up what you can do on your computer in significant ways.
if you're like developing something and you break something. They have nice features where you can take snapshots and roll back. So, for example, here, if we go to this ubuntu virtual machine here, just for demonstration purposes. I can create a snapshot
right now, and you can see it just created this one.
And maybe it's still creating because it slightly froze.
Come on.
Okay, there we go there. It's back. What happened
system problem ignore. Anyway, I created that snapshot. And I was going to delete all these files just to demonstrate that I can bring them back.
But I'll just move them, because I'm kind of scared at my break. But yeah, imagine I just deleted all those files from the folder. Oh, no, whatever will I do, they're gone forever. Well, I created the snapshot, and can just go actions and revert back to the snapshot that I just made
woo.
And now we're back, and the problem that I that it detected, I ignored is back. But the files they're back in the place where they were. Yay.
that's 1 of the fun features of virtual machines. You can like, back them up, or you can do work on one computer and do it in a virtual machine. And if you want to continue that work on a different computer. Well, you can just copy the whole virtual machine. And then all the programs and everything that you had installed is transferred over automatically.
or it's packaged together. Yeah. To continue the amazing
virtual machine features is that if you're in the cloud environment and you have large servers that have hundreds of CPU cores and terabytes of RAM and terabytes of storage. Well.
instead of giving that gigantic computer for one person to use, you can split it up between hundreds or thousands of people
by creating a bunch of virtual machines and then letting users connect to
those individual virtual machines instead of the whole computer.
And that's fundamentally how cloud computing works like the
virtualization and virtual machines are what enabled the cloud to basically exist.
Yeah.
So finally, the last pros of virtual machines is just one that, I added. I think they're pretty fun
to mess with. So hopefully, you get the same amount of enjoyment of playing with new operating systems as I do, and I can share that enthusiasm for computers to you all.
James  Godwin
James  Godwin
01:00:54
Can I ask you a quick question, Robert?
Robert Cordingly
Robert Cordingly
01:00:56
Yeah. Go ahead.
James  Godwin
James  Godwin
01:00:57
Well, I I haven't used. I haven't installed in my m. 1, but like I haven't. But like parallels for Mac is that technically, is that like virtualization? Or is that like a native like App, that just runs windows, programs.
Robert Cordingly
Robert Cordingly
01:01:10
It is virtualization, and it is actually the one that I use personally. So if you see here, if when I go over to windows. 11.
Well, I guess it doesn't show you, but
I personally use parallels, but parallels isn't free, so we will give you free options in this course, that you can use, particularly if you're on an apple silicon, Mac.
it's going to be Utm, and Utm is really good.
But parallels is just a little nicer, and if you end up using virtual machines all the time.
I think it's worth it. But
it can be up to you. But for this course
we don't want anyone having to spend money on.
James  Godwin
James  Godwin
01:01:57
Software to run virtual machines.
Thank you.
Robert Cordingly
Robert Cordingly
01:02:00
Yeah.
yeah. Actually, when I did my little example here of sliding through different virtual machines, the windows 11. One is running in parallels the ubuntu one's running in parallels, and this windows xp. One in the middle is running in Utm.
because this one is technically not a virtual machine. This one is an emulator because windows Xp is not for arm processors. So that is the one caveat is in virtual machines. You have to have a version of that operating system built for the CPU architecture you have. So
this one is actually emulating a whole different CPU type.
That's another thing that you can do
So we went all the through all these pros.
Let's get to some cons. The major drawback is that Vms have
significant overhead to them where basically
running an entirely second operating system in addition to our host operating system.
So programs that you run in virtual machines will run slower than
when they're run on the bare metal.
as what we call when we're running on
the host hardware and the host operating system.
Usually this is not, you know, too horribly bad. It's usually a 10 to 20% performance loss of your programs just being slower. And it's
way way worse. If you're not virtualizing an operating system, and you're emulating. So this windows Xp
machine here is horribly slow.
If I did anything. Oh, I see I have 2 mouses now. Interesting.
but yeah, running things in a virtual machine will have performance.
Losses compared to running in the bare metal alongside that. Gpus! So graphics
cards cannot really be easily split.
As CPU cores or RAM can. So, unless you have, like a second dedicated Gpu, that you can pass through to your virtual machine, then your graphics performance is likely going to be significantly worse.
So, for example, here I talked about the gaming example. If I were in windows I can very easily play 2D games like Stardew Valley or
any indie game. That's 2D. No problem in the virtual machine. But if I were to try and play some fancy. 3D graphics. Modern game, like one that I've always tried is like overwatch that just never ends up working. You just have too bad of performance in a virtual machine, unless you can
have this whole second dedicated gpu to allocate to the virtual machine.
So those are some cons, as you can see, the cons are not particularly bad. In my opinion.
James  Godwin
James  Godwin
01:05:38
Is emulation technically different than virtualization.
Robert Cordingly
Robert Cordingly
01:05:41
Yes, it is different. Yeah. So modern processors will have
will have hardware built into them that allows virtual machines to directly interact with the hardware giving you significant performance boosts. Where, when you're doing emulation, you are simulating an entirely different CPU in software. So that's why performance of emulators is usually significantly worse. And it's actually an example of why I picked
windows Xp. Here, because if I tried to emulate any modern version of windows, even as new as like windows 7. Which is at this point
what almost 1520 years old
performance is going to be awful. So to really have emulators even work. You have to go
a ways back when operating systems were not as demanding, so
yeah, that's the pros and cons in comparison.
So
we're going to take a break here soon, because I've been talking for 43 min, but if you wanted to get started
you can get started with setting up a virtual machine by installing virtualbox. If you're on windows or an Intel, Mac, or Utm, if you're on an apple silicon, Mac and Utm can be installed for free from their github, which this page doesn't have a link to. Unfortunately, this link, this this page here, is just for
virtualbox. But if you go over to assignment one, I'm pretty sure
this gives a very thorough installation guide. So if you want to kind of get ahead and start
chugging through the process of creating a virtual machine during the 15 min break.
This is the best set of instructions, but we'll talk about it a little bit more after
after the break.
So yeah, this was going to be the 1st 10 min break of the day.
Break time. Come, come back at 1031.
It looks like, so yeah.
that's kind of the introduction of virtual machines. And we'll get it into actually creating them. Now in
when we get back.
Okay, welcome back, everyone.
So
if you're getting started a little bit. Well, I'll go through kind of the basics of virtual machine installation here.
Unfortunately. So I just got this new apple
Macbook pro with the new fancy arm processors. And
what that means is, there is a version of virtualbox like in testing for apple silicon.
but I don't have it so.
Unfortunately, I will demonstrate, like creating a virtual machine with the Mac tools.
But you're not going to be able to see the windows one, so they're all like
kind of the same. So what I
talk about in one will apply to the other. But keep in mind. If you use virtualbox, it's going to look different than how it looks in Utm.
But all the guides are online. So
just keep that in mind that the demonstrations might not look exactly the same. But the concepts apply so
unfortunately.
on the break, I was testing this out. So basically how you install ubuntu is you go to the ubuntu.com slash download website and you can just hit download ubuntu desktop. You want the desktop 1. 0, now it works.
A second ago it wasn't working.
Yeah. So yeah, you can just a boon ubuntu download
ubuntu 2024.0 4. And yeah, you can just hit the download button here, and it should start downloading
an iso. And this is how you're going to do it for windows.
You are not going to do this same thing for Mac, unfortunately, because
this is for Amd 64 processors, which are x, 86 processors which are not arm processors.
so I'm sorry if this is horribly confusing, but it's just what we have to deal with, since everyone has different computers. So
once you get your iso downloaded and you're opening up.
Oh, sorry! Dang it!
I'm not screen share. Well, I am screen sharing. But I paused it.
Roll it back. Sorry because I had it paused. So sorry about that.
yeah, so hopefully. Now you can see my screen with the web browser and the thing in the background.
so you're going to be on the ubuntu website here, ubuntu.com slash download.
It'll be this one. And then you're going to want to download ubuntu desktop
not server. Because if you do, server, you're not going to have a graphical user interface. So you want to download ubuntu desktop.
and then you can just download the Lts version here.
It's going to be 6 GB, and it will be larger than that in the future.
But yeah, like, I was saying, you only do this step if you're on windows or an intel, Mac.
you don't do this step. If you're on
an apple silicon, Mac. Because if you're on an apple silicon, Mac, you're going to download Utm.
which utm Github?
Which? Yeah, you can just download straight from their Github Page. Here they have releases, and you can download. The latest one
or the other option is that you can buy Utm from the Mac App store. It's like $10, but
you don't have to. You could also just download it from the Github here and get the Mac OS installer.
But in Utm, once you have it installed, you can just hit the little plus button to make a new virtual machine and click this download pre-built from Utm Gallery.
and then they have an ubuntu 22.0 4 version here. So on.
Apple silicon. You're going to be using a slightly older version of Linux, but that's fine. It's all good.
So that's going to be that. And then all virtual machine software kind of look a little bit like this where you're going to have your list of virtual machines, and then a way for you to edit their specifications once again. Sorry if this is a little small
on the screen size. But
it's kind of what we have to work with. So this one over here is Utm, and you can just have a comparison. This is what parallels is like over here.
So they're all kind of the same.
And once you
is it supposed to be taking an hour to install? It depends on how fast your Internet is.
So maybe the Ubuntu website is not particularly fast in its downloads I have found. So
don't worry about that.
Well, if you're installing, then. Yes, if
if you're just downloading, it might not take an hour.
But yeah. So once you have a virtual machine at least like created.
You can edit the specs of it.
So there's going to be some sort of settings menu somewhere, and then you can define various attributes about the system, such as the amount of memory it has, and the number of CPU cores. In this case it just defaults to some amount.
So for our class. Here is what I recommend for your configuration. You'll want at least 2 CPU cores. Well, not at least
at minimum C 2 CPU cores is a minimum don't go less than that.
As a rule of thumb. The number of Vcpus you can allocate can be up to 2 times the number of physical cores.
If you support hyperthreading, which is just a thing on x. 86 processors.
So, as a rule of Thumb
Allocate, less CPU cores than the number of cores. You actually have
because you don't want to stress your system too much
alongside that you'll want at least 2 GB of RAM allocated to the virtual machine. So once again, if you only have 8 gigs of RAM on your whole computer.
that might be an issue, you might have to close some programs, maybe make sure that the virtual machine is the only thing running on your computer.
If if things are really slow,
and then you'll want to allocate at least 30 GB of storage or more, if you're if available to the virtual machine.
So
once you have things installed and, like your configuration set up, you should be able to run the virtual machine and go through the installer
and a few things that are a little weird about running things inside a virtual machine.
Hopefully, this Vm works.
please. Is that you'll go through the installer? Oh, yes, it's working success.
I already set this one up.
Maybe I don't know the default password, is it? Just password?
Huh?
Maybe I don't.
For some reason Utm sets up a default password. Okay, the default. Password is ubuntu.
Oh, wow! It actually doesn't make you go through the installer for utm, that's cool. I wasn't actually sure of that.
So for virtualbox and parallels, and all the other ones you actually have to go through the full installer. And one thing that's kind of weird
that you have to remember is that you're in a virtual machine. You're not in a real computer. So when the installer asks you if you want to wipe your hard drive and install ubuntu. You say yes, because you're not actually wiping your computer's hard drive, you're wiping the virtual machine's hard drive.
which is virtual. So don't be worried about that.
You aren't gonna destroy your entire computer.
but that's something that you have to keep in mind. And apparently Utm just lets you skip that step?
So I'm just going to close this virtual machine because I thought I would actually go through the installer. But I guess not.
Sean Warlick
Sean Warlick
01:29:10
The other thing I always have to remember is after you've gotten everything installed to unattach the Iso file. Otherwise it wants to boot from the Iso every time.
Robert Cordingly
Robert Cordingly
01:29:20
Yes. And to kind of add explanation to what Sean
is talking about there in the virtual machine. It's it's virtualizing many hardware components of your computer. It's virtualizing the hard drive. It's virtualizing like the keyboard and the mouse and the display. And one of the things that it's also virtualizing is a CD Disk drive.
and when you're installing your Iso with your operating system.
how you would do it back in the olden days is you would
buy a CD. With your Microsoft windows on it, and you would put it in your disk drive, and you would boot from the CD. That all is still happening
exactly the same way. If you're installing the virtual machine and you can see you have the CD and Disk drive here. So
when you set up the virtual machine for the 1st time. You're going to have to virtually put the iso in the disk drive, install your operating system, and then, when you're done
virtually take the disk out of the disk drive. So
if that's confusing, keep that in mind, and are you? Is that
in the steps that you're doing, Maddie, I know I asked about the download. But are you in the actual like installer of Ubuntu?
It might take a while.
Things too.
Maddy
Maddy
01:31:02
I just I don't know. It's just on the side list, and this is pending. It's about a 3rd of the way through.
Robert Cordingly
Robert Cordingly
01:31:10
Yeah, things can take a while to download and install, so I wouldn't worry about it too much as long as it's not taking like
many hours.
Maddy
Maddy
01:31:20
Okay. It says it has about half an hour left.
Robert Cordingly
Robert Cordingly
01:31:24
Yeah, yeah, don't worry about that things. Things take a while like I said, the download was 6 GB. So yeah, depending on your Internet that might take a while. And then
there's a lot of things that it has to do. It has to download stuff, unpack things which
program are you using? Are you using Utm.
Maddy
Maddy
01:31:48
Yeah.
Robert Cordingly
Robert Cordingly
01:31:49
Okay, yeah. So it has to do. Utm, does the entire install for you? It appears
like, I was kind of surprised by that. But yeah, it's it's doing everything for you pretty much automatically. So that's a nice
little feature.
So if there's a
no other questions, we're going to go right into talking about ubuntu and how things work.
So
let me just minimize some things. So this is what the ubuntu desktop looks like. Let me actually
get out of the way whatever that icon is.
So let me just increase my scale so that everything's bigger.
Keep. Okay, that's very big things are very big now, so you should be able to have no problem seeing.
So ubuntu likes its fancy animals. So this version is about whatever this animal is so as mentioned earlier.
ubuntu uses what is called the gnome or gnome.
Don't worry. I know how to pronounce gnome. It's just everything in Linux is pronounced weird. So it's actually pronounced gnome.
yeah. So in the ubuntu interface, you kind of have your little Doc Slash Sidebar here on the left by default, and you have the little ubuntu button down here at the bottom left that can show you what all your installed programs are, and you have fancy little like desktop things, so you can have multiple desktops and search for apps up here.
and you can also access the same menu, or you can see all your open apps by hitting the
pill. Drop thing up in the left here.
So that is kind of the basics of the interface here, and
one of the most important programs that you'll be using on Linux is terminal. So terminal
is just like this. It's a text-based environment where you can do all sorts of fun stuff.
and it's insanely powerful, like tasks that would take like, for example, here, if I wanted to find a specific file in my documents. There's nothing here.
or my downloads where I downloaded game maker. You can do all sorts of tasks that would require a bunch of clicking just in a few lines of code. So if I wanted to go to
my downloads and check out that game maker installer that I was looking at, we could just go to the home folder and then go to downloads.
apparently not, because apparently my home folder is somewheres else.
Oh, because I'm on root the root user.
There we go, and then we can go into our downloads, and if we spell downloads properly.
we can look and see there, there's that game maker installer. So I'm navigating really quite quickly here with the
the terminal.
And you're going to have to learn how to do that a little bit.
So here in the slides we'll go back over to the slides.
It's a few tabs away. I will rearrange my things.
There's a few different little cheat sheets to navigating the terminal and the command line interface of Linux. So to do things you just type your command and hit. Enter to run it. You can use the arrow keys on your computer to move the cursor around. So if I do like echo Hello.
world, you can see the cursor is the flashing rectangle, and I can move it around so
the cursor is always left of whatever character it's kind of highlighting. So if I wanted to change this hello to Jello. You can just do that by moving the cursor around.
And then, if I run this command, all it does is print out whatever text I had after it. So it's like the print statement of the command line
alongside that. The other little cheat sheet
tool that you can use is, you can hit up and down on the Arrow keys to navigate your history of previous commands. So like I just did that
echo Jello World command. It was the last one. If I hit up on the keyboard boom, it shows the last command I did, which was Echo jello world, and I can keep hitting up to see the previous commands. I did, and I can hit down to navigate back and forth. So, for example, there!
In that example, if I made a mistake like I did here, and I want to go to the downloads. But I type downloads wrong. Instead of retyping the whole thing. I could just hit up and fix my typo and run the command properly. And now you can see that both those commands are in my history. If I hit the up and down key on the keyboard. You can see both of those.
So yeah, alongside that you can hit tab on your keyboard to autocomplete commands. So, for example,
the command that I'm using to Change Directory is called CD. And you've seen I typed downloads wrong twice. Now that's way too many times to misspell downloads. So instead of fully typing out downloads, I could just hit CD.
And do DOL. Or WDOW.
And then hit Tab, and it will autocomplete downloads, because that's the only folder
in this directory that started with DOW.
If I just did Cdd and hit Tab. Well, it could be any of these options. So I have to type a little bit more before it will autocomplete one of those options.
so we can go to the desktop, and then we can see that on the desktop we have this week one folder and the parallel shared folder.
That's everything there.
So let me let's go back to the home folder and
talk about a few different things. So that's autocomplete. The next most important control
is control. C, and what control C does is it closes a running program. So one program you also have that you can do is the sleep command. So sleep will sleep for a certain amount of seconds, so you can see here if I hit
sleep 3 seconds and hit. Enter the terminal like pauses for 3 seconds. But let's say I accidentally sleep for this many seconds. Oh, no, my terminal is stuck. I can't do anything
because it's asleep and sleeping, and I can hit control C
to quit the program. And that's the little carrot C here, that's control. C, so now we're back. We're not sleeping anymore. We, we quit the program that was running, which was the sleep program.
So hopefully, that makes sense. So yeah, if if
you're running a program, and all of a sudden your terminal is frozen. You can hit control C to
get out of it.
And the important thing to note for Mac people is that this is not command. C. This is actually control. C, it's not command. C on Mac is still copy.
but control. C is quit in the terminal.
So keep that in mind. I know, Mac. People never use the control button, but
for this you will
And then alongside that, depending on which program you're running. You might have this command overwritten, and it might become something else. It might be Q or control. Q. Or Colon. Q. Exclamation point. If you're using vim.
it all just depends. And you kind of just have to figure it out. Unfortunately.
alongside that control, Z is not undo. It puts a running program in the background. So if you want to run something in the background, I can demonstrate that
by doing sleep 1,000. So we're sleeping for a thousand seconds, and then if I hit control Z.
Oh, it still just stops it.
Oh, no, it doesn't
control Z, so it puts it in the background. And then if I type fg, which is foreground, it starts
running that program again.
Sleep is not exactly the best example for this, but if you're running some python script that like runs for a while and prints things out, and you wanted to
stop it and come back later. You might use control. C control. Z,
so I've used a couple commands here. But let's talk about the most important ones. So CD, and then
the folder you want to go to is call is Change Directory.
That one you'll use all the time to navigate the file system.
And one thing that's not quite obvious is
the anatomy of the terminal here. So the
the text here is the user. So the user on my parallels, virtual machine here is called parallels.
And then the computer is called Ubuntu Linux. 24 0, 4
And then what is between the colon here and the dollar sign is whatever folder you have open. So if I navigate to the downloads once again, you can now see that the folder that I have open is my downloads, and if I
go back so you can go back a folder or up a directory by doing CD change Directory dot, dot.
So we went to the downloads, and then we went back.
and then I can go to the desktop, and then
In the desktop. I don't remember what's there. Well.
you can use another command called Ls to list.
It's not, is. It's Ls to list the contents of the Directory, so we can see that inside my desktop we have the parallel shared folder and a week one folder, so I can just do CD week
and then hit tab to autocomplete.
And now we're in desktop week one, so it will always show you what folder you have open here.
And the other last thing to note is this, Tilde character
represents the home Directory. So that's going to be your home folder with your desktop, your downloads, documents, and whatnot
in Linux, or I guess the better real world example is
in windows. The very 1st folder of your file system is the C Directory right?
Well, in Linux we don't do that. The very 1st folder in your system is forward slash. So if I do this, see forward, slash! This will go to the very topmost root directory of your file system, and you can see we all we have all sorts of different things here, like user boot system, temp
all these different folders, mount, which is where any of your external drives will go the home folder. All sorts of stuff
is in the Root Directory, but that's not super important to know at this moment in time.
And then, if you want to navigate back to your home directory. You can just do CD. Tilde, and it will take you back to your home folder.
which is where your desktop and downloads and music, and all those fun folders are
and keep in mind. You don't
have to use the terminal. You should, because it's an important skill to have.
But keep in mind that everything that you do in the terminal
has a graphical counterpart, so you can open the file manager here in Ubuntu and navigate your folders just like you would
in Mac OS or windows. You can see I go to the desktop we see this week one folder here, and it's got some files in it
all the same.
CD desktop CD week one, and you can see it has the exact same
CPU dot c mem, C thread, dot C files all exactly the same.
So a few other additional commands. Since we've really only been talking about CD and Ls. At this point.
you can also use man, which will open the manual for a program. So let's say, I want to learn more about the CD command. Well, you can type man. CD, in the terminal.
Okay, apparently there's no man for that one.
Okay, there's a manual page for Ls.
so what I did was man Ls, which says, Open the manual for Ls.
and you can see here the different information about it. So you can see Ls, which that means list directory contents, and you can scroll with your mouse to see all sorts of different
flags. So these Dash C character are flags. So let's look for some interesting flags that this program might have.
Oh, yeah, slash l, which is a use long listing format. So whenever you run a command
and to quit the man page, you can see that says you use Q to quit this one.
So if I just hit Q, it quits it.
So now, instead of just running Ls on its own. I can do Ls.
dash, l, and get more information about
the files in this directory. So if I just ran Ls without the L
like this. You can see it. It tells us what files are in the folder. Right? We have CPU CPU C. All of these just as a demonstration.
It's all these folders files. Sorry in the folder.
but if we use the dash l flag we get significantly more information about them.
And what this all is is, you can see the the size of the files, the date that it was created. So it was created yesterday. The names and the the
permissions of the file over here, so you can see, read, write, execute for different users here in different modes.
So you can see here that the C files just have read, write permissions where the executables, the binary executables, which are the ones without file names, have X, which means that they can be executed.
That's the other kind of tricky things about Ubuntu and Linux in general is that files don't need
file or file types.
Files can just be anything.
So in this case we have C files which contain a code, and then the executables themselves, which we can run without a file type.
So if this was windows. These would have like dot exe file types. If it was a Mac, it would have dot app file types.
So there's a few different things in here also beyond just using the manual.
So I definitely recommend, whenever you learn about a new command, check out the manual page, you might learn about some cool features that it might have, that you didn't know about
But in addition to that, if we want to make a folder with the terminal, you can use the make Dir command. So if we're
in here.
you can see that we don't have any folders, and if I wanted to make a directory we can just type Mkdir, and then the name of the Directory.
We'll just call it example boom!
And then, if we list the contacts contents again. You can see now that we have this example Directory, we can do CD example.
and there's nothing in it when we run. Ls.
so now we have this extra folder.
and if we want to move a file around, we can say, well, first, st let's look at what files are in our folder. I definitely recommend spamming Ls constantly. If you forget.
let's say we want to move some of these files like we want to move CPU C into the example folder that we made. Well, you can say, Move, which is Mv. CPU. C, and then where we want to put it, which we want to put it into example. And we're going to call it CPU C.
And now we can see that CPU dot C is gone.
But if we look into the example folder.
it's in there. So we moved it from
not being in the example folder into being in the example folder.
So let's move it back.
Sample CPU dot C. And I'm just going to put it in. CPU dot C.
The
the dot slash that I'm pre pending on all of these commands could be optional. But what it stands for is the current open directory. so.is the current open directory. So this command says, move
the file that
is, in the current directory in the example folder called CPU C to the current folder and call it CPU C. So if that
is making sense, we're saying the source file, and we're moving it to this destination.
And now, if we list the contents again, you can see that CPU dot C is back.
So you can see. We moved it.
We saw that it was in the example folder, and then we moved it back.
So in addition to moving files, you can also copy files, and the copy command is Cp, so we can say, copy CPU C, and then we want to say the name or the path that we want to copy it to. So I'm going to copy it to CPU, 2 dot C.
And now you can see if we list the contents of the Directory. We have 2 files. We made a copy.
So, yeah.
this is all kind of personal preference, but once you get into the groove of using the command line. It can be a lot faster than like
opening the file manager and navigating where you want to go and
right clicking and hit copy and right clicking and hit paste, and then you have to right click and rename and name it whatever you want it to call it.
and then click rename. So
you can see that that whole series of steps I can do by hitting the up arrow twice
and changing the name from number 2 to number 4 and boom. Now we have a copy all like that. We have a bunch of copies of this CPU C file.
So once you get the hang of it and know how to manage the autocomplete using the
command command line can be really fast. So
finally, another useful command in our little cheat sheet. Here is Rm. Or rmder. This can remove files. So we made a whole bunch of copies of the CPU C file, so we can say, rm.
CPU, 4 dot C.
And now we have deleted that file, and we can delete file number 3, and we can delete file number 2. And now we're back
to just having
those files in our directory that we started with. And you can see here once again, if we go to the file manager. It's back to what we were at before.
Yeah. So that's the final real command. As I mentioned earlier, Fg, can bring things from the background.
To the foreground. That's another little command that you can work with.
So I think this is a perfectly good place to take our next break.
That was kind of the little virtual machine demo that will go
through, for now we'll talk about virtual machines more in the future. But that was just the basics of navigating them.
So with that we will say, Break time. Come back at 11
20. It'll be a 11 min break this time, so
come on back in 10 min.
Okay? And we're back. I'm very, very
bright for some reason in this camera view.
Yeah. So
with the second half of this lecture. We're kind of switching gears a little bit. So in the 1st part, we were all talking about virtual machines. But now we're actually going to be talking about
concepts of operating systems. So this is.
keep in mind, we're talking about operating systems kind of in the broad sense. We're not talking about any one operating system in particular, all operating systems, whether it's Mac OS. Linux
windows all do the same things fundamentally.
So we're going to be starting off and talking about. Chapter 2 of the book
which is called 3 Easy Pieces.
And we're going to introduce operating systems and how they go about managing the hardware resources they have.
and we'll be talking about the concepts of virtualization and abstraction, and keep in mind that
this is kind of a hard thing to explain a little bit. But the concepts of virtualization in the sense of virtual machines
is a real thing, so like
there can be virtualization, hardware and components of the CPU, and there can be the concept of virtualization
in the operating system sense. So now we're going to go to the conceptual side of things.
So hopefully, that's not too confusing, because we use the same word for 2 different things a little bit.
So the operating system, in our conceptual sense
has 3 main components to it, virtualizing the CPU virtualizing memory and virtualizing
input output. I/O operations. So those are the 3 components of what an operating system needs to do. And there's many different ways. It can go about doing that. And we'll get into talking about that.
And we'll talk about operating system design goals.
So to get started with the files that I showed in the kind of operating system. Walkthrough. You can find them on canvas under files week one. So if you want to follow along and do the exact same things that I'm doing in the lecture, you can download the files there, the CPU C CPU or memc and threadc.
so.
Sean Warlick
Sean Warlick
02:10:34
That's the maybe the one piece that didn't show up in canvas. There's a week 10 shared, but
week, 10.
Robert Cordingly
Robert Cordingly
02:10:42
Is shared. Okay, let's go. Let's go over here into the files and then we go.
Oh, oh, let's unshare that one. You guys don't get early. Looks a week. 10.
Okay.
Yep. That was an oopsie typo or me, not clicking the right thing. Okay, so week one should now be available. Sorry about that. Thank you for letting me know
what was even in week 10.
Oh, just the slides.
Okay, those are old slides, anyway. You don't need them.
Okay, so good to know. Thank you for letting me know.
So
the number one job of the operating system is to run programs. That's like its number one job, what it has to do. And every time that your computer wants to run a program it has to do a few different things. It has to
fetch instructions to run so like your lines of code, it gets them from memory. It's not exactly your lines of code, but it fetches instructions from memory, it decodes them into what instructions need to run, and then it executes those instructions on the hardware itself.
So if you write a line of code that
is like in Python. It's like X plus
equals 5. Well, it needs to fetch that instruction from memory. Figure out
where the variable it's editing is in memory.
Run the math.
run the pieces of the hardware on your computer that does math and save the result back into memory.
and then it moves on to run the next instruction.
And then your computer repeats this millions or billions of times a second. So that's
that's fundamentally how programs run on your computer and the number one job.
So what does
the operating system do in particular? Well, it's responsible for making it easy to run programs. You don't need to write your code in binary or individual instructions in assembly you can use nice high level languages like Python or Java, or whatever
the operating system is also making it so that you can run many programs on your computer and share physical memory between those programs.
And then the last thing that your operating system needs to be able to do is allow you to interact with devices, whether that's a hard drive, or a SSD. Or a keyboard, or a mouse, or a display, or any other devices. The operating system is the middleman that makes your programs be able to interact with all different kinds of hardware.
and the OS. Is in charge of managing the system and making sure it operates correctly and efficiently. So
that's what the OS. Is meant to do so
once again. We're now in the operating system concept of virtualization.
So what the operation does is it takes physical resources like the actual hardware, the the rocks that we have put electricity into to do math, that is the CPU or the memory.
It takes the physical hardware and provides virtual forms of them that your programs use.
So, for example, it takes various physical resources like your CPU cores, their processors.
your memory, which is your RAM and your storage devices, which is like your hard drive, or your SSD. And provides virtual forms of them that are general, more powerful, and easy to use. So the virtual forms of those 3 I mentioned are processes and threads which are the virtual form of the CPU
variables or data structures
or the virtual memory space. We'll talk about that more later which is the virtual form of RAM and the file system, which is like your files and folders, which is the virtual form
of storage space.
So these virtual forms of these different resources. And this is
this, this slide is going to be on a quiz. Just so you know, these virtual forms of these hardware devices are more abstract
than the physical form.
So what do does the OS provide? Like? I mentioned, the virtual form of the CPU is processes and threads. The virtual form of memory is the virtual address space, where you can store large arrays of bytes, which is fundamentally just a large array of bytes
alongside that every program in the operating system will see the same size of RAM.
There's some trickery going on there with the RAM that you'll see later. And the virtual form of the file system or the disk is the file system files and folders.
So why do we need these abstract forms. Well, it allows you to write programs that reuse common features.
We make a whole bunch of different devices.
all look exactly the same to your program. So, for example.
when you are writing a python program that writes to a folder right?
That folder could be stored
on an Sd card, it could be stored on a hard drive. It could be stored on an SSD. It could be stored on tape. It could be in the cloud. It could be just on RAM. There's a whole bunch of different devices that you could be writing data to.
And you don't care because your program is just going out to the operating system and saying, Hey, I want to write this data at this place. And then the operating system itself is the one responsible for actually talking to the device itself. So it might have different drivers depending on what different devices you have. But from your perspective, from any program's perspective.
all these potentially different devices all look exactly the same. It's just a folder in the file system.
but it could be a whole bunch of different things.
And this. This example is just for for
storage devices, but it applies to everything you're
there's like, we're dealing with these problems nowadays, where people have arm processors with apple, silicon, macs, or they could be arm processors with
raspberry, pi's or windows, ones or x 86 processors with windows or intel or amd. There's a whole bunch of different hardware, and the further back, in time you go, the more crazy it gets with a whole bunch of different types of cpus.
But all of this applies to everything like when you make a game you don't have to care about what kind of display. Well, you do have to care a bit a little bit. But
ultimately every display is pretty much the same from a program perspective. All different types of RAM are the same, like you could have different speeds or quantities or different types.
But from programs perspective, the operating system abstracts this all away. And you just see
these tools that it gives you.
So
that was a kind of long-winded explanation of why we want to have these abstract virtual forms of different hardware components.
So there is a little bit of a balance to it, though, because we can actually like how the operating system is designed, can have more or less abstraction. So, for example, if you have
a ton of abstraction, you might have worse performance. But if you have less abstraction and you allow programs to directly interact with hardware devices.
you might have better performance, but you might have less security. So there's always a trade-off between everything
that we do in computer science.
And this is one of them.
So how do we interact with these abstract forms?
Well, we do it through things called system calls.
And in python these are all kind of built in. So anytime you use the OS or system.
A library in python, and you do like OS. Dot
read a file or write a file.
They're all going out and making system calls to the operating system.
So the operating system allows certain Apis and interfaces for users to interact with. So the typical system calls that you might have are to like run programs, access memory access devices which is like reading and writing to files.
These are all things that your program
will do in the background. So anytime you want to read a file, you do. OS, dot read, give it a path.
Your python program will go out and say, Hey, get on the phone with the operating system. Be like, Hey, I want to read this file.
You don't say, Hey, I want to read the bytes at location 10 million.
You give it the file. And then the operating system is like, okay, it's the one responsible figuring out where the data is on the hard drive or SSD and give it back to you
in the form of a file.
So you're always talking with the operating system.
So ultimately the goal of the operating system is to be a resource manager. It manages the physical hardware, CPU memory and disk.
and it enables and a variety of things such as many programs on the computer can run at the same time, and all share the same cpus CPU cores
alongside that many programs can run concurrently and access their own
set of instructions and data and share memory, but remain isolated from other programs. Many programs can get access to the disk and devices all
at the same time. And that's what the operating system does.
It manages those resources.
So we've had a broad introduction to the all the different types of virtual devices. But now we're going to specifically talk about virtualizing the CPU or the central processing unit.
So what the operating system does
is it provides a system of basically simulating the CPU
and having a very large number of cpus. So we know from the hardware survey that
everyone in this course has 4 or more CPU cores.
But to our programs running they might think that there is way more than that. So
back in the olden days one CPU only can run one thing at a time, and that's still true.
But
the operating system gives the illusion of basically taking one CPU, and having a seemingly infinite number of cpus. And this allows us to run many, many programs at the same time.
even though only one thing can run at the CPU at one time.
So the OS presents an illusion that each program has its own hardware. That's the main idea.
Each program thinks that it's running on a computer with no one else. It has its own hardware, and it does this through the idea of processes and threads
for the CPU.
So if you go on your computer, and whether you're on Mac on the left there, or Linux in the middle or windows on the right, there, you will see that your computer is often running hundreds, if not thousands, of processes. So you can see here
in a
let me get my little laser pointer. You can see here in windows we have 173 processes in Linux. Here you can see we have 130 tasks, and in, Mac you can see we have 800 processes, and this remains true.
For all of this. So if I go on over to
my ubuntu virtual machine here. And then I open a program called System Monitor.
You can see that I have a whole bunch of processes running, and I guess it doesn't actually show you a number unless I go like this. You can see that my ubuntu virtual machine here is running 118 processes. If I go
to my windows virtual machine and open task manager, you can see that it has
173 processes running, and I'm sure if I went on my real Mac here.
it has even more, because.
even though you might think that you only have a couple programs running on your computer at any given moment. There's a ton of things going on in the background, like, right now, I'm running Zoom and Google slides. And all these virtual machines and a whole bunch of
safari tabs and a whole bunch of things open all at the same time. And all of these processes
take up processes.
So, to give a general idea of
simulating or visualizing a process running, we have this CPU C code.
and all that does is it will repeatedly print out
a string. So this code is once again under files week one.
So it takes the arguments from the terminal, and then it creates an infinite loop here that says, while one which is the same thing as while true, it will
print out this print statement, and this spin function just waits a given amount of time.
So how we take these C files and run them
is, we 1st need to compile them. So
in your terminal you can type Gcc dash! O, and then the name of the executable that you want, and then the the file that you want, and that will compile it.
So if we go back to our virtual machine here.
and we clear out the terminal, and then let me just remove a file.
Ls.
you can see this CPU C file, and if we want to compile it into executable, we can say, Gcc, dash! O,
the name of the executable we want, which we'll call CPU. It could be anything. And then the path to the C file, which is just CPU dot, C.
Can we run that?
And we can see Ls Ls, and you can see now we have this CPU executable.
and to run things in the terminal we do dot slash
CPU. If I just run that, you can see that it says I did it wrong, and that I need to put a string here so we can take type, dot slash CPU.
Hello.
And now, what this program does is it just repeatedly prints out Hello, and then sleeps for a second.
So we have a process running right?
It's running forever. This is
the same thing as any other process. Programs. Just run until you stop them and we can hit C to close it.
So
what if we wanted to run multiple processes at the same time. Well, in terminal, you can actually do that by putting the little Ampersand sign and then putting more than one command.
So if we do that, we can say that slash CPU, and then our string, which will say, one
ampersand dot CPU 2, and that's a dollar sign and dot slash CPU 3, and
dash slash CPU or so. What this is going to do is it creates
4 processes that are all printing out 1, 2, 3, or 4, depending on the process. Right?
But you'll notice something here. That's kind of interesting.
What? What is interesting about this?
The order is not consistent. Right? Is it doing the same order? 1, 2, 4, 3, 2, 3, 3.
It's it's well!
The order might not be consistent because all these programs are running independently of each other. They're not defined to run this 1 1st and then the next one and the next one. It's all up to the operating system to choose how they run.
So that's an example of, you know, a process. And we're going to have to do some funky things to get these all to close.
and then they're all closed.
So what I had to do there was, I did control C
to close one. And then I typed fg, because some of them were in the background to the foreground.
So that's
basically a process. And when we start this program for the 1st time, you'll also notice. Oh, I guess it doesn't do it. Never mind, we'll get to that later.
Each process has its own individual identifier
called a process Id, which we'll get to in a little bit.
So that's just a really simple program that our computer is running.
So to virtualize memory.
And don't worry. We'll get into all these topics in more depth later.
What our program or the operating system does to
divide up the memory is the the memory is physical hardware on the computer. But what the operating system does is it keeps a
while. The physical memory is just an array of bytes and the operating system. A pro sorry.
I'm getting ahead of myself.
Every program that you run keeps all of its data structures that you use, whether it's variables in memory.
And it has 2 specific operations that it needs to be able to do. It needs to read memory load avail data from specific locations.
and it needs to be able to write memory and store data at given locations. So whenever you create a variable
in your program, you are
writing to memory. And when you're doing math or an if statement you're reading from memory, all of these happen in the background.
and the operating system is the one responsible for managing the addresses.
So if we look at this other C program that we have here, this one's a little bit more complicated. So I'll walk through what all lines of code are doing here.
So we are initializing a chunk of memory here. That's what the malloc
does. It stands for memory allocate. You allocate memory, and we're allocating a chunk
of the size of an integer. So this is probably 8 8 Byte, 8 Byte of memory.
and then we print out the address of that memory and the process. Id excuse me.
and then we enter a loop that runs forever, and we continually increment the value that's in that memory location.
So what we can do here now is we can run the Mem file.
and I have already compiled it. So I skipped that step
so you can see that we have a process with process id
2, 1, 9, 7, 9, 6.
And I'm going to quit it
just so that we can look at it. We create this variable P,
we allocate memory. And then in C, you can actually see the addresses
where that memory is located. So we can print that out just in this print statement here.
And we can see that that variable we made
is allocated at this address, which is a hexadecimal value of
a a c, 12, a. 8 a. O, 0 whatever.
So what's interesting? So that's like
an address? Right? That is a location.
But what if I take this terminal window and make a new window?
And you know, Whoa, okay, what happened there?
Why do we? Okay, just imagine this one is put on the side here.
and let's zoom this one down a little bit.
And then in both of these, at the same time I run the memory function.
Do any of you see what's weird that's happening
about the output, particularly the 1st line.
We have one process
with this process. Id, and you can see why I stop it and start it. We have a different process. Id.
Sean Warlick
Sean Warlick
02:36:47
Still in. It's still in memory. The same location.
Robert Cordingly
Robert Cordingly
02:36:51
Yeah. But in this side the variable P is up to 18. But on this side the variable is only at 15. So there
they're the same address, but they're different values.
Sean Warlick
Sean Warlick
02:37:07
Oh, they're not well, the increments not getting written back to memory. Then.
Robert Cordingly
Robert Cordingly
02:37:12
Not quite. It's because these these addresses are virtual. Every process has its own virtual memory space.
So every process has its own private space.
So even though they had the same address.
they're still different locations in memory.
So that's kind of a little trick that was happening there. So
each program, thought it was writing to the same address. But it's not because every process has its own virtual address space.
and even though it looks like it was doing the same thing.
They are completely different. They're separated from each other.
And that's what the operating system does. It provides this illusion to processes that everything's the same.
But
and that there's only one thing running on the computer at once. But in reality we're dividing this hardware up between a whole bunch of different processes, and the operating system is the one who facilitates that.
So the other question. I don't expect
you all to be all set up at this point.
But if you were to run what I just did in the same exact way, you will see something different.
because
ubuntu now works differently. So ubuntu updated a couple years ago, so that now the default location in memory that variables write to is randomized. So you actually have to make a change on your virtual machine to disable
pointer randomization to get the same result that I did.
But it's still a good thing to demonstrate that, hey?
These processes think they're writing at the same location in memory.
But they're not because the operating system is the one separating them.
So the key takeaway of this little memory. Virtualization. Example is that each project or each process
has its own private virtual address, space.
and then the operating system is the one responsible for mapping. The virtual address, space to the physical location memory.
So a memory reference in one program does not affect the address space of other running programs. The operating system is isolating them
from each other, and the physical memory is a shared resource managed by the OS.
Is it possible to see where the OS is actually writing the data to then?
So
in the world of Linux anything's impossible. You can run your programs in kernel mode and have full access to the hardware.
The question of, Do I specifically know how to do that off the top of my head?
The answer to that would be, No, but yeah, anything is impossible. Anything's possible.
Unlike closed source operating systems like Mac OS or windows.
Linux lets you do anything so that is definitely possible.
And honestly, you could probably find a Linux distribution that like doesn't even isolate memory from multiple programs. You can find all sorts of things. So.
But that's still a major security vulnerability, because you definitely do not want
multiple programs being able to interfere with each other's memory because that could end up crashing your system or causing all sorts of problems.
So that is the memory example.
Finally, the last of the 3 easy pieces of operating system design in the last 5 min of class is virtualizing storage. So
devices such as dram, which is your memory, are in a volatile state. So what that means is, when you shut off your computer, everything is lost. So that's why, like
pick route or blip.
Sorry. That's why restarting your computer will like fix all your problems. Because sometimes a program will be running, and then it messes something up in the memory, and or a
gamma ray from the sun hits your computer and flips a bit. And now things aren't working for some reason. By restarting your computer, you flush the RAM and refill it
fresh.
To
potentially fix things. This is why you might lose progress if you have, like a power outage or unplug your computer. And like, I said, it's why it fixes 99% of problems with computers.
But
when we write software, we need to persist data. Sometimes sometimes data is important to keep around for a while.
So our computers have devices. I/O devices like a hard drive or a solid state drive that can persist data after a power cycle and for long periods of time.
And the way that we interact with those devices is through the file system.
So the file system is responsible for storing files. The user creates and retrieving them.
So to persistently store a file on a computer. Well, you need to find a location to write to. So what this program does here is it writes the data, Hello, world to
the directory, temp, slash, file.
And any time we do, certain function calls like this open function, or the write function or the close function are all
talking to the operating system, to to
interact with the actual physical devices, whether it's a hard drive or an SSD, so for that example. Here
we can clear. Ls, oh, wait! Do I not have this file?
Oh, I don't have that one.
Well, that's fine. You don't need to see a demonstration. It just writes a file to a folder. It's not that amazing.
So yeah.
that is how we achieve persistence. We write files to folders. And what happens? What the OS does in order to write data, is it figures out where on disk we need to write to? So this could be like the physical location on a hard drive, and then it issues. I/O requests to that device to do the operation that we want.
So file systems often have fancy features to handle. System crashes when you write data. So they might have a
a feature called journaling, where, instead of like writing all the data all the time. It just writes changes, and you have this record of how the file system changes over time, or you might have this a feature called copy on, write where it
it copies the data and keeps a second copy of it every single time you write. And this is all to prevent
data loss on crashes, and it carefully maintains an order when it writes data to the disks.
So as a little like last summary, we didn't get through. Well, we'll get through the last couple slides here.
So the overall design goals of an operating system is to build these abstraction layers so that the system is convenient and easy to use. We want to achieve high performance so that we can run things real fast
without a bunch of extra overhead.
that we have. So the OS. Must strive to provide these nice virtual forms of the CPU memory and and disk without a ton of extra overhead.
And then finally, well, not. Finally, there's another slide. The OS needs to have protection between applications. So we don't want programs interacting with each other. And we don't want programs to be able to do things that harm the OS itself or the hardware.
And there's a typo in that slide.
And then, finally, the last 2 design goals of an operating system is that we need a high degree of reliability. The operating system needs to be able to run nonstop 24, 7 for days or weeks, or months at a time, without any crashes. Sometimes windows is not able to do that. We've all seen the blue screen of death
And then alongside that poor user programs or malicious user programs should not be able to bring the system down.
It can still happen sometimes
alongside that operating systems might have a few other design goals depending on their application. So, for example, like they might care heavily about energy efficiency if it was on like a phone or a laptop.
and then you might have other features like high levels of security. There's specific Linux distributions that are tailored to be more secure than others.
and then an operating system might be designed to be exclusively used on the cloud. So, for example, there's things like Amazon Linux, which might be designed to specifically run a large number of virtual machines.
So that's the end of today's
time. I believe we will continue going into more depth next time about concurrency and virtualizing the CPU. But I think that's the end of today's lecture.
The last little bits of things to note is, I will
a startup doing office hours on Fridays starting up soon.
And the final thing is that assignment one
is, oh, I need to organize these better
is available. So the 1st assignment
is this introduction to Linux. So you need to create a virtual machine, get it running, start playing around with the virtual machine, and play with some different commands, like I was in
today's lecture.
And there's a few questions that you have to find commands to solve. So I will be talking about this more next week also.
And yeah.
so get started with that. If you have run into troubles or have questions feel free to message me. Otherwise.
yeah, this is the end of today's lecture.
I'll stick around for a few minutes, but otherwise I hope you all have a good rest of your day in Tcss.
5. 0, 6, right 6. Later on. So I think that's about it.
Sean Warlick
Sean Warlick
02:50:19
Thank you. Have a nice weekend.
Robert Cordingly
Robert Cordingly
02:50:22
Yep, you too.
Liam Wilkenson
Liam Wilkenson
02:50:25
Hey, Robert.
